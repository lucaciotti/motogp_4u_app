// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'record_type_unionclass.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

class _$RecordTypeTearOff {
  const _$RecordTypeTearOff();

// ignore: unused_element
  _EverLap everLap() {
    return const _EverLap();
  }

// ignore: unused_element
  _BestLap bestLap() {
    return const _BestLap();
  }

// ignore: unused_element
  _BestPole bestPole() {
    return const _BestPole();
  }

// ignore: unused_element
  _TopSpeed topSpeed() {
    return const _TopSpeed();
  }
}

// ignore: unused_element
const $RecordType = _$RecordTypeTearOff();

mixin _$RecordType {
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result everLap(),
    @required Result bestLap(),
    @required Result bestPole(),
    @required Result topSpeed(),
  });
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result everLap(),
    Result bestLap(),
    Result bestPole(),
    Result topSpeed(),
    @required Result orElse(),
  });
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result everLap(_EverLap value),
    @required Result bestLap(_BestLap value),
    @required Result bestPole(_BestPole value),
    @required Result topSpeed(_TopSpeed value),
  });
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result everLap(_EverLap value),
    Result bestLap(_BestLap value),
    Result bestPole(_BestPole value),
    Result topSpeed(_TopSpeed value),
    @required Result orElse(),
  });
}

abstract class $RecordTypeCopyWith<$Res> {
  factory $RecordTypeCopyWith(
          RecordType value, $Res Function(RecordType) then) =
      _$RecordTypeCopyWithImpl<$Res>;
}

class _$RecordTypeCopyWithImpl<$Res> implements $RecordTypeCopyWith<$Res> {
  _$RecordTypeCopyWithImpl(this._value, this._then);

  final RecordType _value;
  // ignore: unused_field
  final $Res Function(RecordType) _then;
}

abstract class _$EverLapCopyWith<$Res> {
  factory _$EverLapCopyWith(_EverLap value, $Res Function(_EverLap) then) =
      __$EverLapCopyWithImpl<$Res>;
}

class __$EverLapCopyWithImpl<$Res> extends _$RecordTypeCopyWithImpl<$Res>
    implements _$EverLapCopyWith<$Res> {
  __$EverLapCopyWithImpl(_EverLap _value, $Res Function(_EverLap) _then)
      : super(_value, (v) => _then(v as _EverLap));

  @override
  _EverLap get _value => super._value as _EverLap;
}

class _$_EverLap implements _EverLap {
  const _$_EverLap();

  @override
  String toString() {
    return 'RecordType.everLap()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _EverLap);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result everLap(),
    @required Result bestLap(),
    @required Result bestPole(),
    @required Result topSpeed(),
  }) {
    assert(everLap != null);
    assert(bestLap != null);
    assert(bestPole != null);
    assert(topSpeed != null);
    return everLap();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result everLap(),
    Result bestLap(),
    Result bestPole(),
    Result topSpeed(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (everLap != null) {
      return everLap();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result everLap(_EverLap value),
    @required Result bestLap(_BestLap value),
    @required Result bestPole(_BestPole value),
    @required Result topSpeed(_TopSpeed value),
  }) {
    assert(everLap != null);
    assert(bestLap != null);
    assert(bestPole != null);
    assert(topSpeed != null);
    return everLap(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result everLap(_EverLap value),
    Result bestLap(_BestLap value),
    Result bestPole(_BestPole value),
    Result topSpeed(_TopSpeed value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (everLap != null) {
      return everLap(this);
    }
    return orElse();
  }
}

abstract class _EverLap implements RecordType {
  const factory _EverLap() = _$_EverLap;
}

abstract class _$BestLapCopyWith<$Res> {
  factory _$BestLapCopyWith(_BestLap value, $Res Function(_BestLap) then) =
      __$BestLapCopyWithImpl<$Res>;
}

class __$BestLapCopyWithImpl<$Res> extends _$RecordTypeCopyWithImpl<$Res>
    implements _$BestLapCopyWith<$Res> {
  __$BestLapCopyWithImpl(_BestLap _value, $Res Function(_BestLap) _then)
      : super(_value, (v) => _then(v as _BestLap));

  @override
  _BestLap get _value => super._value as _BestLap;
}

class _$_BestLap implements _BestLap {
  const _$_BestLap();

  @override
  String toString() {
    return 'RecordType.bestLap()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _BestLap);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result everLap(),
    @required Result bestLap(),
    @required Result bestPole(),
    @required Result topSpeed(),
  }) {
    assert(everLap != null);
    assert(bestLap != null);
    assert(bestPole != null);
    assert(topSpeed != null);
    return bestLap();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result everLap(),
    Result bestLap(),
    Result bestPole(),
    Result topSpeed(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (bestLap != null) {
      return bestLap();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result everLap(_EverLap value),
    @required Result bestLap(_BestLap value),
    @required Result bestPole(_BestPole value),
    @required Result topSpeed(_TopSpeed value),
  }) {
    assert(everLap != null);
    assert(bestLap != null);
    assert(bestPole != null);
    assert(topSpeed != null);
    return bestLap(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result everLap(_EverLap value),
    Result bestLap(_BestLap value),
    Result bestPole(_BestPole value),
    Result topSpeed(_TopSpeed value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (bestLap != null) {
      return bestLap(this);
    }
    return orElse();
  }
}

abstract class _BestLap implements RecordType {
  const factory _BestLap() = _$_BestLap;
}

abstract class _$BestPoleCopyWith<$Res> {
  factory _$BestPoleCopyWith(_BestPole value, $Res Function(_BestPole) then) =
      __$BestPoleCopyWithImpl<$Res>;
}

class __$BestPoleCopyWithImpl<$Res> extends _$RecordTypeCopyWithImpl<$Res>
    implements _$BestPoleCopyWith<$Res> {
  __$BestPoleCopyWithImpl(_BestPole _value, $Res Function(_BestPole) _then)
      : super(_value, (v) => _then(v as _BestPole));

  @override
  _BestPole get _value => super._value as _BestPole;
}

class _$_BestPole implements _BestPole {
  const _$_BestPole();

  @override
  String toString() {
    return 'RecordType.bestPole()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _BestPole);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result everLap(),
    @required Result bestLap(),
    @required Result bestPole(),
    @required Result topSpeed(),
  }) {
    assert(everLap != null);
    assert(bestLap != null);
    assert(bestPole != null);
    assert(topSpeed != null);
    return bestPole();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result everLap(),
    Result bestLap(),
    Result bestPole(),
    Result topSpeed(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (bestPole != null) {
      return bestPole();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result everLap(_EverLap value),
    @required Result bestLap(_BestLap value),
    @required Result bestPole(_BestPole value),
    @required Result topSpeed(_TopSpeed value),
  }) {
    assert(everLap != null);
    assert(bestLap != null);
    assert(bestPole != null);
    assert(topSpeed != null);
    return bestPole(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result everLap(_EverLap value),
    Result bestLap(_BestLap value),
    Result bestPole(_BestPole value),
    Result topSpeed(_TopSpeed value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (bestPole != null) {
      return bestPole(this);
    }
    return orElse();
  }
}

abstract class _BestPole implements RecordType {
  const factory _BestPole() = _$_BestPole;
}

abstract class _$TopSpeedCopyWith<$Res> {
  factory _$TopSpeedCopyWith(_TopSpeed value, $Res Function(_TopSpeed) then) =
      __$TopSpeedCopyWithImpl<$Res>;
}

class __$TopSpeedCopyWithImpl<$Res> extends _$RecordTypeCopyWithImpl<$Res>
    implements _$TopSpeedCopyWith<$Res> {
  __$TopSpeedCopyWithImpl(_TopSpeed _value, $Res Function(_TopSpeed) _then)
      : super(_value, (v) => _then(v as _TopSpeed));

  @override
  _TopSpeed get _value => super._value as _TopSpeed;
}

class _$_TopSpeed implements _TopSpeed {
  const _$_TopSpeed();

  @override
  String toString() {
    return 'RecordType.topSpeed()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _TopSpeed);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result everLap(),
    @required Result bestLap(),
    @required Result bestPole(),
    @required Result topSpeed(),
  }) {
    assert(everLap != null);
    assert(bestLap != null);
    assert(bestPole != null);
    assert(topSpeed != null);
    return topSpeed();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result everLap(),
    Result bestLap(),
    Result bestPole(),
    Result topSpeed(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (topSpeed != null) {
      return topSpeed();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result everLap(_EverLap value),
    @required Result bestLap(_BestLap value),
    @required Result bestPole(_BestPole value),
    @required Result topSpeed(_TopSpeed value),
  }) {
    assert(everLap != null);
    assert(bestLap != null);
    assert(bestPole != null);
    assert(topSpeed != null);
    return topSpeed(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result everLap(_EverLap value),
    Result bestLap(_BestLap value),
    Result bestPole(_BestPole value),
    Result topSpeed(_TopSpeed value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (topSpeed != null) {
      return topSpeed(this);
    }
    return orElse();
  }
}

abstract class _TopSpeed implements RecordType {
  const factory _TopSpeed() = _$_TopSpeed;
}
